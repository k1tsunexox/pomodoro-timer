// File: PomodoroTimer.java
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

public class PomodoroTimer {
    public enum Phase { WORK, SHORT_BREAK, LONG_BREAK, IDLE }
    public enum State { RUNNING, PAUSED, STOPPED }

    public static class PomodoroConfig {
        public final int workSeconds;
        public final int shortBreakSeconds;
        public final int longBreakSeconds;
        public final int cyclesBeforeLongBreak; // e.g., 4

        public PomodoroConfig(int workSeconds, int shortBreakSeconds, int longBreakSeconds, int cyclesBeforeLongBreak) {
            this.workSeconds = workSeconds;
            this.shortBreakSeconds = shortBreakSeconds;
            this.longBreakSeconds = longBreakSeconds;
            this.cyclesBeforeLongBreak = cyclesBeforeLongBreak;
        }
    }

    public interface TimerListener {
        void onTick(Phase phase, int secondsLeft);
        void onPhaseChange(Phase newPhase);
        void onStateChange(State newState);
        void onCompleteCycle(int completedCycles);
    }

    // Core state
    private final PomodoroConfig config;
    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor(r -> {
        Thread t = new Thread(r, "pomodoro-scheduler");
        t.setDaemon(true);
        return t;
    });

    private final AtomicReference<Phase> currentPhase = new AtomicReference<>(Phase.IDLE);
    private final AtomicReference<State> currentState = new AtomicReference<>(State.STOPPED);
    private final AtomicInteger secondsLeft = new AtomicInteger(0);
    private final AtomicInteger completedCycles = new AtomicInteger(0);
    private TimerListener listener;
    private ScheduledFuture<?> tickFuture;

    public PomodoroTimer(PomodoroConfig config) {
        this.config = config;
    }

    public void setListener(TimerListener listener) {
        this.listener = listener;
    }

    // Start fresh
    public synchronized void start() {
        if (currentState.get() == State.RUNNING) return;
        completedCycles.set(0);
        goToPhase(Phase.WORK);
        resumeInternal();
    }

    // Pause (can resume)
    public synchronized void pause() {
        if (currentState.get() != State.RUNNING) return;
        currentState.set(State.PAUSED);
        cancelTick();
        notifyState();
    }

    // Resume from pause or from stopped if IDLE not set
    public synchronized void resume() {
        if (currentState.get() == State.RUNNING) return;
        resumeInternal();
    }

    // Stop everything and reset
    public synchronized void stop() {
        currentState.set(State.STOPPED);
        cancelTick();
        currentPhase.set(Phase.IDLE);
        secondsLeft.set(0);
        notifyState();
        notifyPhase();
    }

    // Move to next phase (public for manual control)
    public synchronized void nextPhase() {
        advancePhase();
    }

    private void resumeInternal() {
        currentState.set(State.RUNNING);
        notifyState();
        scheduleTick();
    }

    private void goToPhase(Phase phase) {
        currentPhase.set(phase);
        secondsLeft.set(phaseDurationSeconds(phase));
        notifyPhase();
        notifyTick(); // immediate UI update
    }

    private int phaseDurationSeconds(Phase phase) {
        switch (phase) {
            case WORK: return config.workSeconds;
            case SHORT_BREAK: return config.shortBreakSeconds;
            case LONG_BREAK: return config.longBreakSeconds;
            default: return 0;
        }
    }

    private void scheduleTick() {
        cancelTick();
        tickFuture = scheduler.scheduleAtFixedRate(() -> {
            int left = secondsLeft.decrementAndGet();
            notifyTick();
            if (left <= 0) {
                handlePhaseEnd();
            }
        }, 1, 1, TimeUnit.SECONDS); // tick every second
    }

    private void cancelTick() {
        if (tickFuture != null && !tickFuture.isCancelled()) tickFuture.cancel(false);
    }

    private synchronized void handlePhaseEnd() {
        // when a WORK phase completes, a cycle increments
        if (currentPhase.get() == Phase.WORK) {
            int cycles = completedCycles.incrementAndGet();
            if (listener != null) listener.onCompleteCycle(cycles);
        }
        advancePhase();
    }

    private void advancePhase() {
        Phase phase = currentPhase.get();
        switch (phase) {
            case WORK:
                if (completedCycles.get() % config.cyclesBeforeLongBreak == 0 && completedCycles.get() != 0) {
                    goToPhase(Phase.LONG_BREAK);
                } else {
                    goToPhase(Phase.SHORT_BREAK);
                }
                break;
            case SHORT_BREAK:
            case LONG_BREAK:
                goToPhase(Phase.WORK);
                break;
            case IDLE:
                goToPhase(Phase.WORK);
                break;
        }
        if (currentState.get() == State.RUNNING) {
            scheduleTick();
        }
    }

    // Query helpers
    public Phase getPhase() { return currentPhase.get(); }
    public State getState() { return currentState.get(); }
    public int getSecondsLeft() { return secondsLeft.get(); }
    public int getCompletedCycles() { return completedCycles.get(); }

    // Listener notifications
    private void notifyTick() {
        if (listener != null) listener.onTick(currentPhase.get(), Math.max(0, secondsLeft.get()));
    }

    private void notifyPhase() {
        if (listener != null) listener.onPhaseChange(currentPhase.get());
    }

    private void notifyState() {
        if (listener != null) listener.onStateChange(currentState.get());
    }

    // graceful shutdown to free the scheduler threads
    public void shutdown() {
        stop();
        scheduler.shutdownNow();
    }
}
